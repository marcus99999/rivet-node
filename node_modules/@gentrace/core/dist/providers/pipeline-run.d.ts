import { Configuration } from "../configuration";
import { RunResponse } from "../models/run-response";
import { Context, CoreStepRunContext } from "./context";
import { StepRun, PartialStepRunType } from "./step-run";
type PRStepRunType = Omit<PartialStepRunType, "context"> & {
    context?: CoreStepRunContext;
};
interface PipelineLike {
    slug: string;
    config: Configuration;
    logInfo: (message: string) => void;
    logWarn: (message: string | Error) => void;
}
type PipelineRunPayload = {
    id: string;
    slug: string;
    metadata: {};
    previousRunId: string;
    collectionMethod: "runner";
    stepRuns: StepRun[];
};
type SelectStepRun = Pick<StepRun, "inputs" | "outputs" | "modelParams" | "context">;
type StepRunWhitelistDescriptor = Partial<{
    [k in keyof SelectStepRun]: boolean | string[] | (string[] | string)[] | string;
}>;
export declare const getRun: (id: string) => Promise<import("../models").RunV2>;
export declare class PipelineRun {
    private pipeline;
    stepRuns: StepRun[];
    context?: Context;
    private id;
    private instantiationTime;
    constructor({ pipeline, context, }: {
        pipeline: PipelineLike;
        context?: Context;
    });
    getPipeline(): PipelineLike;
    getId(): string;
    getContext(): Context;
    updateContext(updatedContext: Partial<Context>): Context;
    addStepRunNode(stepRun: StepRun): Promise<void>;
    /**
     * Creates a checkpoint by recording a `StepRun` instance with execution metadata and pushes it to `this.stepRuns`.
     * If no prior `StepRun` instances exist, the elapsed time is set to 0 and the start and end times are set to the
     * current timestamp. If it is empty, elapsed time is set to 0 and start time and end time are set to the current
     * timestamp.
     *
     * @param {PRStepRunType & { inputs: any; outputs: any; }} step The information about the step to checkpoint.
     * This includes the inputs and outputs of the step, as well as optional provider, invocation and modelParams metadata.
     *
     * @example
     * const stepInfo = {
     *   providerName: 'MyProvider',
     *   invocation: 'doSomething',
     *   inputs: { x: 10, y: 20 },
     *   outputs: { result: 30 }
     * };
     * checkpoint(stepInfo);
     *
     * @returns {void} The function does not return anything.
     *
     * @throws {Error} If the `StepRun` constructor or any other operations throw an error, it will be propagated.
     */
    checkpoint(step: PRStepRunType & {
        inputs: any;
        outputs: any;
    }): void;
    /**
     * Asynchronously measures the execution time of a function.
     *
     * @template F Function type that extends (...args: any[]) => any
     * @param {F} func The function to be measured.
     * @param {Parameters<F>} inputs The parameters to be passed to the function.
     * @param {Omit<PRStepRunType, "inputs" | "outputs">} [stepInfo] Optional metadata for the function execution.
     * @returns {Promise<ReturnType<F>>} Returns a promise that resolves to the return type of the function.
     *
     * @example
     * async function foo(n: number) {
     *   return n * 2;
     * }
     * const result = await measure(foo, [2]); // result will be 4
     *
     * The function also records a `StepRun` instance with execution metadata and pushes it to `this.stepRuns`.
     * The recorded `StepRun` includes information such as the elapsed time, start and end time,
     * resolved inputs, and model parameters if provided.
     */
    measure<F extends (...args: any[]) => any>(func: F, inputs: Parameters<F>, stepInfo?: Omit<PRStepRunType, "inputs" | "outputs">): Promise<ReturnType<F>>;
    toObject(): PipelineRunPayload;
    toJson(): string;
    static getRedactedRunFromJson(json: string | object, options?: {
        waitForServer?: boolean;
        pipeline?: PipelineLike;
        selectFields?: StepRunWhitelistDescriptor | ((steps: StepRun[]) => StepRunWhitelistDescriptor[]);
    }): PipelineRunPayload;
    static submitFromJson(json: string | object, options?: {
        waitForServer?: boolean;
        pipeline?: PipelineLike;
        selectFields?: StepRunWhitelistDescriptor | ((steps: StepRun[]) => StepRunWhitelistDescriptor[]);
    }): Promise<RunResponse>;
    submit({ waitForServer, selectFields, }?: {
        waitForServer?: boolean;
        selectFields?: StepRunWhitelistDescriptor | ((steps: StepRun[]) => StepRunWhitelistDescriptor[]);
    }): Promise<RunResponse>;
}
export {};
