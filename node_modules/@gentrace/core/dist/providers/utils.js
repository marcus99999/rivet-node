'use strict';

var acorn = require('acorn');
var globalAxios = require('axios');

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function getSingleParamName(param, index) {
    if (param.type === "Identifier") {
        return param.name;
    }
    else if (param.type === "AssignmentPattern" &&
        param.left.type === "Identifier") {
        return param.left.name;
    }
    else {
        // If the parameter is a destructured object/array, we can't get the name
        return `param${index}`;
    }
}
function getParamNamesAnonymousFunction(func) {
    let inputs = [];
    try {
        const result = acorn.parse(`(${func.toString()})`, {
            ecmaVersion: 2020,
        });
        const firstElement = result.body[0];
        if (!firstElement) {
            return inputs;
        }
        if (firstElement.type === "ExpressionStatement") {
            const expression = firstElement.expression;
            if (expression.type === "FunctionExpression") {
                inputs = expression.params.map(getSingleParamName);
            }
        }
    }
    catch (e) {
        // Do nothing
    }
    return inputs;
}
function getParamNames(func) {
    let inputs = [];
    try {
        const result = acorn.parse(func.toString(), {
            ecmaVersion: 2020,
        });
        const functionNode = result.body[0];
        if (!functionNode) {
            return inputs;
        }
        if (functionNode.type === "FunctionDeclaration") {
            inputs = functionNode.params.map(getSingleParamName);
        }
        else if (functionNode.type === "ExpressionStatement") {
            const expression = functionNode.expression;
            if (expression.type === "ArrowFunctionExpression") {
                inputs = expression.params.map(getSingleParamName);
            }
        }
    }
    catch (e) {
        // There's a chance that the passed function is a regular anonymous function (which is un-parseable by acorn)
        return getParamNamesAnonymousFunction(func);
    }
    return inputs;
}
function zip(firstCollection, lastCollection) {
    const length = Math.min(firstCollection.length, lastCollection.length);
    const zipped = [];
    for (let index = 0; index < length; index++) {
        zipped.push([firstCollection[index], lastCollection[index]]);
    }
    return zipped;
}
let TEST_COUNTER = 0;
function getTestCounter() {
    return TEST_COUNTER;
}
function incrementTestCounter() {
    TEST_COUNTER += 1;
    return TEST_COUNTER;
}
function decrementTestCounter() {
    TEST_COUNTER -= 1;
    return TEST_COUNTER;
}
function getProcessEnv(name) {
    if (typeof process === "undefined") {
        return null;
    }
    return process.env[name];
}
function safeJsonParse(jsonString) {
    try {
        return JSON.parse(jsonString !== null && jsonString !== void 0 ? jsonString : "");
    }
    catch (error) {
        return null;
    }
}
function getContextTestCaseFilter(contextOrCaseFilter, caseFilterOrUndefined) {
    let context, caseFilter;
    // Determine the overload being used based on the types of arguments
    if (typeof contextOrCaseFilter === "function") {
        caseFilter = contextOrCaseFilter;
        context = undefined;
    }
    else {
        context = contextOrCaseFilter;
        caseFilter = caseFilterOrUndefined;
    }
    return { context, caseFilter };
}
let lastErrorCheckpoint = Date.now(); // used for error throttling
let errorSent = false; // make sure first error is always shown
function setErrorInterceptor(showErrorsInput) {
    globalAxios.interceptors.response.use((response) => response, (error) => {
        var _a, _b, _c, _d, _e;
        let showErrors = showErrorsInput;
        if (showErrorsInput) {
            showErrors = showErrorsInput.toLowerCase();
        }
        if (showErrors === "none") {
            return Promise.reject("");
        }
        if (showErrors === "all") {
            return Promise.reject(error);
        }
        // default path: make the error message more user friendly
        const now = Date.now();
        let friendlyMessage = new Date(now).toUTCString(); // timestamp
        if ((_a = error.config) === null || _a === void 0 ? void 0 : _a.url) {
            friendlyMessage += "\nGentrace URL: " + error.config.url;
        }
        if (error.message === "Network Error") {
            friendlyMessage +=
                "\nA network error occurred. Please check your connection.";
        }
        else if (error.message) {
            friendlyMessage += "\nError message: " + error.message;
        }
        if ((_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.message) {
            friendlyMessage += "\nðŸ›‘ " + error.response.data.message;
        }
        if ((_e = (_d = error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.errors) {
            friendlyMessage +=
                "\nðŸ›‘ Errors: " + JSON.stringify(error.response.data.errors, null, 2);
        }
        if (error.code === "ECONNABORTED") {
            friendlyMessage += "\nThe request timed out. Please try again later.";
        }
        else if (error.code) {
            friendlyMessage += "\nError code: " + error.code;
        }
        if (error.status) {
            friendlyMessage += "\nError status: " + error.status;
        }
        // show errors at most every 10 seconds
        // (errors that occur in between are throttled)
        if (errorSent === false || now - lastErrorCheckpoint > 10000) {
            errorSent = true;
            lastErrorCheckpoint = now;
            return Promise.reject(friendlyMessage);
        }
        else {
            return Promise.reject(""); // throttled error
        }
    });
}
/**
 * Constructs step runs for a given test case and pipeline run.
 *
 * @param {TestCase | TestCaseV2} testCase - The test case object.
 * @param {PipelineRun} pipelineRun - The pipeline run object.
 * @returns {TestRun} The constructed test run object.
 */
function constructStepRuns(testCase, pipelineRun) {
    let mergedMetadata = {};
    const updatedStepRuns = pipelineRun.stepRuns.map((stepRun) => {
        var _a, _b;
        let _c = (_a = pipelineRun.context) !== null && _a !== void 0 ? _a : {}, { metadata: thisContextMetadata, previousRunId: _prPreviousRunId } = _c, restThisContext = __rest(_c, ["metadata", "previousRunId"]);
        let _d = (_b = stepRun.context) !== null && _b !== void 0 ? _b : {}, { metadata: stepRunContextMetadata, previousRunId: _srPreviousRunId } = _d, restStepRunContext = __rest(_d, ["metadata", "previousRunId"]);
        // Merge metadata
        mergedMetadata = Object.assign(Object.assign(Object.assign({}, mergedMetadata), thisContextMetadata), stepRunContextMetadata);
        return {
            modelParams: stepRun.modelParams,
            invocation: stepRun.invocation,
            inputs: stepRun.inputs,
            outputs: stepRun.outputs,
            providerName: stepRun.providerName,
            elapsedTime: stepRun.elapsedTime,
            startTime: stepRun.startTime,
            endTime: stepRun.endTime,
            context: Object.assign(Object.assign({}, restThisContext), restStepRunContext),
        };
    });
    const testRun = {
        caseId: testCase.id,
        metadata: mergedMetadata,
        stepRuns: updatedStepRuns,
    };
    if (pipelineRun.getId()) {
        testRun.id = pipelineRun.getId();
    }
    return testRun;
}

exports.constructStepRuns = constructStepRuns;
exports.decrementTestCounter = decrementTestCounter;
exports.getContextTestCaseFilter = getContextTestCaseFilter;
exports.getParamNames = getParamNames;
exports.getProcessEnv = getProcessEnv;
exports.getTestCounter = getTestCounter;
exports.incrementTestCounter = incrementTestCounter;
exports.safeJsonParse = safeJsonParse;
exports.setErrorInterceptor = setErrorInterceptor;
exports.zip = zip;
//# sourceMappingURL=utils.js.map
