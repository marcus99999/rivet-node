import { constructStepRuns, getContextTestCaseFilter, incrementTestCounter, decrementTestCounter } from './utils.mjs';
import { globalGentraceApi } from './init.mjs';
import { getTestCasesForDataset, getTestCases } from './test-case.mjs';
import { constructSubmissionPayloadAdvanced } from './test-result.mjs';
import { getPipelines } from './pipeline-methods.mjs';

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function runTestCore(pipelineSlug, handler, context, caseFilter, datasetId) {
    return __awaiter(this, void 0, void 0, function* () {
        incrementTestCounter();
        try {
            const allPipelines = yield getPipelines();
            const matchingPipeline = allPipelines.find((pipeline) => pipeline.slug === pipelineSlug);
            if (!matchingPipeline) {
                throw new Error(`Could not find the specified pipeline (${pipelineSlug})`);
            }
            const testCases = datasetId
                ? yield getTestCasesForDataset(datasetId)
                : yield getTestCases(pipelineSlug);
            const testRuns = [];
            for (const testCase of testCases) {
                if (caseFilter && !caseFilter(testCase)) {
                    continue;
                }
                const [, pipelineRun] = yield handler(testCase);
                const testRun = constructStepRuns(testCase, pipelineRun);
                testRuns.push(testRun);
            }
            if (!globalGentraceApi) {
                throw new Error("Gentrace API key not initialized. Call init() first.");
            }
            const body = constructSubmissionPayloadAdvanced(matchingPipeline.id, testRuns, context);
            const response = yield globalGentraceApi.v1TestResultPost(body);
            return response.data;
        }
        catch (e) {
            throw e;
        }
        finally {
            decrementTestCounter();
        }
    });
}
function runTest(pipelineSlug, handler, contextOrCaseFilter, caseFilterOrUndefined) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context, caseFilter } = getContextTestCaseFilter(contextOrCaseFilter, caseFilterOrUndefined);
        return runTestCore(pipelineSlug, handler, context, caseFilter);
    });
}
/**
 * Runs a test for a given pipeline slug and dataset ID.
 * @param {string} pipelineSlug: The slug of the pipeline
 * @param {string} datasetId: The ID of the dataset
 * @param {function} handler: The handler function that will be called for each test case
 * @param {ResultContext | function} [contextOrCaseFilter]: An optional context object that will be passed to the Gentrace API
 * @param {function} [caseFilterOrUndefined]: An optional filter function that will be called for each test case
 */
function runTestWithDataset(pipelineSlug, datasetId, handler, contextOrCaseFilter, caseFilterOrUndefined) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context, caseFilter } = getContextTestCaseFilter(contextOrCaseFilter, caseFilterOrUndefined);
        return runTestCore(pipelineSlug, handler, context, caseFilter, datasetId);
    });
}

export { runTest, runTestWithDataset };
//# sourceMappingURL=run-test.mjs.map
