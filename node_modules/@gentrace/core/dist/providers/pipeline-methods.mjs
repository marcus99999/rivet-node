import { globalGentraceApi } from './init.mjs';

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Retrieves pipelines from the Gentrace API.
 * @async
 * @param {PipelineParams} [params] - Optional parameters to filter the pipelines.
 * @returns {Promise<Array<Pipeline>>} - A promise that resolves to an array of pipelines.
 * @throws {Error} - Throws an error if the Gentrace API key is not initialized.
 */
const getPipelines = (params) => __awaiter(void 0, void 0, void 0, function* () {
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    const label = (params !== null && params !== void 0 ? params : {}).label;
    const slug = (params !== null && params !== void 0 ? params : {}).slug;
    const parameters = [label, slug];
    const response = yield globalGentraceApi.v1PipelinesGet(...parameters);
    return response.data.pipelines;
});

export { getPipelines };
//# sourceMappingURL=pipeline-methods.mjs.map
