import { globalGentraceApi } from './init.mjs';
import { constructSubmissionPayloadAdvanced } from './test-result.mjs';
import { constructStepRuns, getContextTestCaseFilter } from './utils.mjs';

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Retrieves test runners for a given pipeline
 * @async
 * @param {Pipeline<{ [key: string]: GentracePlugin<any, any> }>} pipeline - The pipeline instance
 * @param {string} [datasetId] - Optional dataset ID to filter test cases by.
 * @throws {Error} Throws an error if the SDK is not initialized. Call init() first.
 * @returns {Promise<Array<PipelineRunTestCaseTuple>>} A Promise that resolves with an array of PipelineRunTestCaseTuple.
 */
const getTestRunners = (pipeline, datasetId, caseFilter) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!globalGentraceApi) {
        throw new Error("Gentrace API key not initialized. Call init() first.");
    }
    if (!pipeline) {
        throw new Error(`Invalid pipeline found`);
    }
    // get test cases for the pipeline
    let response;
    if (datasetId) {
        response = yield globalGentraceApi.v1TestCaseGet(datasetId, undefined, undefined);
    }
    else if (pipeline.id) {
        response = yield globalGentraceApi.v1TestCaseGet(undefined, pipeline.id, undefined);
    }
    else {
        response = yield globalGentraceApi.v1TestCaseGet(undefined, undefined, pipeline.slug);
    }
    const testCases = (_a = response.data.testCases) !== null && _a !== void 0 ? _a : [];
    // create tuples of pipeline run and test case
    const testRunners = [];
    for (const testCase of testCases) {
        if (caseFilter && !caseFilter(testCase)) {
            continue;
        }
        const pipelineRun = pipeline.start();
        testRunners.push([pipelineRun, testCase]);
    }
    return testRunners;
});
/**
 * Submits test runners for a given pipeline
 * @async
 * @param {Pipeline<{ [key: string]: GentracePlugin<any, any> }>} pipeline - The pipeline instance
 * @param {Array<PipelineRunTestCaseTuple>} pipelineRunTestCases - an array of PipelineRunTestCaseTuple
 * @param {ResultContext | function} [contextOrCaseFilter]: An optional context object that will be passed to the Gentrace API
 * @param {function} [caseFilterOrUndefined]: An optional filter function that will be called for each test case
 */
function submitTestRunners(pipeline, pipelineRunTestCases, contextOrCaseFilter, caseFilterOrUndefined) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { context, caseFilter } = getContextTestCaseFilter(contextOrCaseFilter, caseFilterOrUndefined);
        try {
            if (!pipeline) {
                throw new Error(`Invalid pipeline found`);
            }
            const testRuns = [];
            for (const [pipelineRun, testCase] of pipelineRunTestCases) {
                if (caseFilter && !caseFilter(testCase)) {
                    continue;
                }
                const testRun = constructStepRuns(testCase, pipelineRun);
                testRuns.push(testRun);
            }
            if (!globalGentraceApi) {
                throw new Error("Gentrace API key not initialized. Call init() first.");
            }
            const body = constructSubmissionPayloadAdvanced((_a = pipeline.id) !== null && _a !== void 0 ? _a : pipeline.slug, testRuns, context);
            const response = yield globalGentraceApi.v1TestResultPost(body);
            return response.data;
        }
        catch (e) {
            throw e;
        }
    });
}
/**
 * Updates a test result with the provided runners.
 *
 * @async
 * @param {string} resultId - The ID of the test result to update.
 * @param {Array<PipelineRunTestCaseTuple>} runners - Additional test runs to add to the existing test result.
 * @returns {Promise<any>} A Promise that resolves with the response data from the Gentrace API.
 * @throws {Error} Throws an error if the update operation fails.
 */
function updateTestResultWithRunners(resultId, runners) {
    return __awaiter(this, void 0, void 0, function* () {
        const testRuns = [];
        for (const [pipelineRun, testCase] of runners) {
            const testRun = constructStepRuns(testCase, pipelineRun);
            testRuns.push(testRun);
        }
        const response = yield globalGentraceApi.v1TestResultIdPost(resultId, {
            testRuns,
        });
        return response.data;
    });
}

export { getTestRunners, submitTestRunners, updateTestResultWithRunners };
//# sourceMappingURL=runners.mjs.map
