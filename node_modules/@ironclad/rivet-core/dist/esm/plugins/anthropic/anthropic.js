import fetchEventSource from './fetchEventSource.js';
export const anthropicModels = {
    'claude-instant-1': {
        maxTokens: 100_000,
        cost: {
            prompt: 0.00163,
            completion: 0.00551,
        },
        displayName: 'Claude Instant',
    },
    'claude-instant-1.2': {
        maxTokens: 100_000,
        cost: {
            prompt: 0.8e-6,
            completion: 2.4e-6,
        },
        displayName: 'Claude Instant 1.2',
    },
    'claude-2': {
        maxTokens: 100_000,
        cost: {
            prompt: 8e-6,
            completion: 24e-6,
        },
        displayName: 'Claude 2',
    },
    'claude-2.1': {
        maxTokens: 200_000,
        cost: {
            prompt: 8e-6,
            completion: 24e-6,
        },
        displayName: 'Claude 2.1',
    },
    'claude-3-haiku-20240307': {
        maxTokens: 200_000,
        cost: {
            prompt: 0.25e-6,
            completion: 1.25e-6,
        },
        displayName: 'Claude 3 Haiku',
    },
    'claude-3-sonnet-20240229': {
        maxTokens: 200_000,
        cost: {
            prompt: 3e-6,
            completion: 15e-6,
        },
        displayName: 'Claude 3 Sonnet',
    },
    'claude-3-opus-20240229': {
        maxTokens: 200_000,
        cost: {
            prompt: 15e-6,
            completion: 75e-6,
        },
        displayName: 'Claude 3 Opus',
    },
    'claude-3-5-sonnet-latest': {
        maxTokens: 200_000,
        cost: {
            prompt: 3e-6,
            completion: 15e-6,
        },
        displayName: 'Claude 3.5 Sonnet',
    },
    'claude-3-5-haiku-latest': {
        maxTokens: 200_000,
        cost: {
            prompt: 0.8e-6,
            completion: 4e-6,
        },
        displayName: 'Claude 3.5 Haiku',
    },
};
export const anthropicModelOptions = Object.entries(anthropicModels).map(([id, { displayName }]) => ({
    value: id,
    label: displayName,
}));
export async function* streamChatCompletions({ apiEndpoint, apiKey, signal, ...rest }) {
    const defaultSignal = new AbortController().signal;
    const response = await fetchEventSource(`${apiEndpoint}/completions`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
            ...rest,
            stream: true,
        }),
        signal: signal ?? defaultSignal,
    });
    let hadChunks = false;
    let nextDataType;
    for await (const chunk of response.events()) {
        hadChunks = true;
        if (chunk === '[DONE]') {
            return;
        }
        else if (/\[\w+\]/.test(chunk)) {
            nextDataType = chunk.slice(1, -1);
            continue;
        }
        let data;
        try {
            data = JSON.parse(chunk);
        }
        catch (err) {
            console.error('JSON parse failed on chunk: ', chunk);
            throw err;
        }
        yield data;
    }
    if (!hadChunks) {
        const responseJson = await response.json();
        throw new AnthropicError(`No chunks received. Response: ${JSON.stringify(responseJson)}`, response, responseJson);
    }
}
export async function callMessageApi({ apiEndpoint, apiKey, signal, tools, beta, ...rest }) {
    const defaultSignal = new AbortController().signal;
    const response = await fetch(`${apiEndpoint}/messages`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            ...(beta ? { 'anthropic-beta': beta } : {}),
        },
        body: JSON.stringify({
            ...rest,
            tools,
            stream: false,
        }),
        signal: signal ?? defaultSignal,
    });
    const responseJson = await response.json();
    if (response.status !== 200) {
        throw new AnthropicError(responseJson?.error?.message ?? 'Request failed', response, responseJson);
    }
    return responseJson;
}
export async function* streamMessageApi({ apiEndpoint, apiKey, signal, beta, ...rest }) {
    // Use the Messages API for Claude 3 models
    const defaultSignal = new AbortController().signal;
    const response = await fetchEventSource(`${apiEndpoint}/messages`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            ...(beta ? { 'anthropic-beta': beta } : {}),
        },
        body: JSON.stringify({
            ...rest,
            stream: true,
        }),
        signal: signal ?? defaultSignal,
    });
    let hadChunks = false;
    let nextDataType;
    for await (const chunk of response.events()) {
        hadChunks = true;
        if (chunk === '[message_stop]') {
            return;
        }
        else if (/\[\w+\]/.test(chunk)) {
            nextDataType = chunk.slice(1, -1);
            continue;
        }
        let data;
        try {
            data = JSON.parse(chunk);
        }
        catch (err) {
            console.error('JSON parse failed on chunk: ', chunk);
            throw err;
        }
        yield data;
    }
    if (!hadChunks) {
        const responseJson = await response.json();
        throw new AnthropicError(`No chunks received. Response: ${JSON.stringify(responseJson)}`, response, responseJson);
    }
}
export class AnthropicError extends Error {
    response;
    responseJson;
    constructor(message, response, responseJson) {
        super(message);
        this.response = response;
        this.responseJson = responseJson;
    }
}
