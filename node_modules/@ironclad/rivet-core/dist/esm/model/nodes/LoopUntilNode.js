import {} from '../NodeBase.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import {} from '../NodeGraph.js';
import { nanoid } from 'nanoid/non-secure';
import {} from '../Project.js';
import {} from './GraphInputNode.js';
import {} from './GraphOutputNode.js';
import {} from '../DataValue.js';
import {} from '../ProcessContext.js';
import {} from '../EditorDefinition.js';
import { dedent } from 'ts-dedent';
export class LoopUntilNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'loopUntil',
            title: 'Loop Until',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 200,
            },
            data: {
                targetGraph: undefined,
                conditionType: 'allOutputsSet',
            },
        };
        return chartNode;
    }
    getInputDefinitions(_connections, _nodes, project) {
        const inputs = [];
        // Get inputs from the target graph
        const graph = project.graphs[this.data.targetGraph ?? ''];
        if (graph) {
            const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput');
            const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();
            inputIds.forEach((id) => {
                const inputNode = inputNodes.find((node) => node.data.id === id);
                inputs.push({
                    id: id,
                    title: id,
                    dataType: inputNode.data.dataType,
                });
            });
        }
        return inputs;
    }
    getOutputDefinitions(_connections, _nodes, project) {
        const outputs = [];
        // Get outputs from the target graph
        const graph = project.graphs[this.data.targetGraph ?? ''];
        if (graph) {
            const outputNodes = graph.nodes.filter((node) => node.type === 'graphOutput');
            const outputIds = [...new Set(outputNodes.map((node) => node.data.id))].sort();
            outputIds.forEach((id) => {
                const outputNode = outputNodes.find((node) => node.data.id === id);
                outputs.push({
                    id: id,
                    title: id,
                    dataType: outputNode.data.dataType,
                });
            });
        }
        // Add standard loop outputs
        outputs.push({
            id: 'iteration',
            title: 'Iterations',
            dataType: 'number',
            description: 'The number of iterations completed.',
        }, {
            id: 'completed',
            title: 'Completed',
            dataType: 'boolean',
            description: 'True when the loop has completed.',
        });
        return outputs;
    }
    getEditors(context) {
        const definitions = [
            {
                type: 'graphSelector',
                label: 'Target Graph',
                dataKey: 'targetGraph',
            },
            {
                type: 'dropdown',
                dataKey: 'conditionType',
                label: 'Stop Condition',
                options: [
                    { label: 'All Outputs Set', value: 'allOutputsSet' },
                    { label: 'Input Equals Value', value: 'inputEqual' },
                ],
                helperMessage: 'The condition that will stop the loop',
            },
            {
                type: 'number',
                dataKey: 'maxIterations',
                label: 'Max Iterations',
                helperMessage: 'Maximum number of iterations (optional, leave empty for unlimited)',
                allowEmpty: true,
            },
        ];
        if (this.data.conditionType === 'inputEqual') {
            definitions.push({
                type: 'string',
                dataKey: 'inputToCheck',
                label: 'Input to Check',
                helperMessage: 'The name of the input to compare',
            }, {
                type: 'string',
                dataKey: 'targetValue',
                label: 'Target Value',
                helperMessage: 'The value to compare against',
            });
        }
        // Add dynamic editors for graph inputs
        if (this.data.targetGraph) {
            const graph = context.project.graphs[this.data.targetGraph];
            if (graph) {
                const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput');
                const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();
                for (const inputId of inputIds) {
                    const inputNode = inputNodes.find((node) => node.data.id === inputId);
                    definitions.push({
                        type: 'dynamic',
                        dataKey: 'inputData',
                        dynamicDataKey: inputNode.data.id,
                        dataType: inputNode.data.dataType,
                        label: inputNode.data.id,
                        editor: inputNode.data.editor ?? 'auto',
                    });
                }
            }
        }
        return definitions;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Executes a subgraph in a loop until a condition is met. Each iteration's outputs become
        the inputs for the next iteration. Supports different stopping conditions and optional
        maximum iterations.
      `,
            infoBoxTitle: 'Loop Until Node',
            contextMenuTitle: 'Loop Until',
            group: ['Logic'],
        };
    }
    getBody(context) {
        if (!this.data.targetGraph) {
            return 'No target graph selected';
        }
        const graphName = context.project.graphs[this.data.targetGraph]?.metadata?.name ?? 'Unknown Graph';
        const condition = this.data.conditionType === 'allOutputsSet'
            ? 'all outputs are set'
            : `${this.data.inputToCheck} equals ${this.data.targetValue}`;
        const maxIterations = this.data.maxIterations ? `\nMax iterations: ${this.data.maxIterations}` : '';
        return `Executes ${graphName}\nuntil ${condition}${maxIterations}`;
    }
    checkCondition(outputs) {
        if (this.data.conditionType === 'allOutputsSet') {
            // Check if any output is control-flow-excluded
            const anyInputIsExcluded = Object.values(outputs)
                .filter((o) => o != null)
                .some((output) => output.type === 'control-flow-excluded');
            return !anyInputIsExcluded;
        }
        else if (this.data.conditionType === 'inputEqual' && this.data.inputToCheck && this.data.targetValue) {
            const inputValue = outputs[this.data.inputToCheck];
            return inputValue?.value?.toString() === this.data.targetValue;
        }
        return false;
    }
    async process(inputs, context) {
        if (!this.data.targetGraph) {
            throw new Error('No target graph selected');
        }
        let iteration = 0;
        let currentInputs = { ...inputs };
        // Add any default values from inputData
        if (this.data.inputData) {
            Object.entries(this.data.inputData).forEach(([key, value]) => {
                if (currentInputs[key] === undefined) {
                    currentInputs[key] = value;
                }
            });
        }
        let lastOutputs = {};
        while (!context.signal.aborted) {
            // Check max iterations if set
            if (this.data.maxIterations && iteration >= this.data.maxIterations) {
                break;
            }
            const subprocessor = context.createSubProcessor(this.data.targetGraph, { signal: context.signal });
            lastOutputs = await subprocessor.processGraph(context, currentInputs, context.contextValues);
            iteration++;
            // Check if the condition is met
            if (this.checkCondition(lastOutputs)) {
                break;
            }
            context.onPartialOutputs?.(lastOutputs);
            // Use outputs as inputs for next iteration
            currentInputs = lastOutputs;
        }
        return {
            ...lastOutputs,
            ['iteration']: { type: 'number', value: iteration },
            ['completed']: { type: 'boolean', value: true },
        };
    }
}
export const loopUntilNode = nodeDefinition(LoopUntilNodeImpl, 'Loop Until');
