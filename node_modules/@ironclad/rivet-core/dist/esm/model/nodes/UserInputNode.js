import { NodeImpl } from '../NodeImpl.js';
import { nanoid } from 'nanoid/non-secure';
import { zip } from 'lodash-es';
import {} from '../../index.js';
import { dedent } from 'ts-dedent';
import { nodeDefinition } from '../NodeDefinition.js';
import { coerceType } from '../../utils/coerceType.js';
import {} from '../ProcessContext.js';
export class UserInputNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'userInput',
            title: 'User Input',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 250,
            },
            data: {
                prompt: 'This is an example question?',
                useInput: false,
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        if (this.chartNode.data.useInput) {
            return [
                {
                    dataType: 'string[]',
                    id: 'questions',
                    title: 'Questions',
                },
            ];
        }
        return [];
    }
    getOutputDefinitions() {
        return [
            {
                dataType: 'string[]',
                id: 'output',
                title: 'Answers Only',
            },
            {
                dataType: 'string[]',
                id: 'questionsAndAnswers',
                title: 'Q & A',
            },
        ];
    }
    getEditors() {
        return [
            {
                type: 'code',
                label: 'Prompt',
                dataKey: 'prompt',
                useInputToggleDataKey: 'useInput',
                language: 'plain-text',
            },
            {
                type: 'group',
                label: 'Rendering',
                editors: [
                    {
                        type: 'dropdown',
                        dataKey: 'renderingFormat',
                        label: 'Format',
                        options: [
                            { label: 'Preformatted', value: 'preformatted' },
                            { label: 'Markdown', value: 'markdown' },
                        ],
                        defaultValue: 'markdown',
                    },
                ],
            },
        ];
    }
    getBody() {
        return this.data.useInput ? '(Using input)' : this.data.prompt;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Prompts the user for input during the execution of the graph. The user's response becomes the output of this node.
      `,
            infoBoxTitle: 'User Input Node',
            contextMenuTitle: 'User Input',
            group: ['Input/Output'],
        };
    }
    async process(inputs, context) {
        const questions = this.data.useInput ? coerceType(inputs['questions'], 'string[]') : [this.data.prompt];
        const renderingFormat = this.data.renderingFormat === 'preformatted' ? 'text' : 'markdown';
        const response = await context.requestUserInput(questions, renderingFormat);
        return {
            ['output']: {
                type: 'string[]',
                value: response.value,
            },
            ['questionsAndAnswers']: {
                type: 'string[]',
                value: zip(questions, response.value).map(([q, a]) => `${q}\n${a}`),
            },
        };
    }
}
export const userInputNode = nodeDefinition(UserInputNodeImpl, 'User Input');
