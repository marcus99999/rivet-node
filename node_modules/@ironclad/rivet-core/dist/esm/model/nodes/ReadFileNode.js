import {} from '../NodeBase.js';
import {} from '../DataValue.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import { nanoid } from 'nanoid/non-secure';
import { getInputOrData } from '../../utils/index.js';
import {} from '../ProcessContext.js';
import { dedent } from 'ts-dedent';
export class ReadFileNodeImpl extends NodeImpl {
    static create() {
        return {
            id: nanoid(),
            type: 'readFile',
            title: 'Read File',
            visualData: { x: 0, y: 0, width: 250 },
            data: {
                path: '',
                asBinary: false,
                usePathInput: true,
                errorOnMissingFile: false,
            },
        };
    }
    getInputDefinitions() {
        const inputDefinitions = [];
        if (this.chartNode.data.usePathInput) {
            inputDefinitions.push({
                id: 'path',
                title: 'Path',
                dataType: 'string',
                coerced: false,
            });
        }
        return inputDefinitions;
    }
    getOutputDefinitions() {
        return [
            {
                id: 'content',
                title: 'Content',
                dataType: this.data.asBinary ? 'binary' : 'string',
            },
        ];
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Reads the contents of the specified file and outputs it as a string.
      `,
            infoBoxTitle: 'Read File Node',
            contextMenuTitle: 'Read File',
            group: ['Input/Output'],
        };
    }
    getEditors() {
        return [
            {
                type: 'filePathBrowser',
                label: 'Path',
                dataKey: 'path',
                useInputToggleDataKey: 'usePathInput',
            },
            {
                type: 'toggle',
                label: 'Error on Missing File',
                dataKey: 'errorOnMissingFile',
            },
            {
                type: 'toggle',
                label: 'Read as Binary',
                dataKey: 'asBinary',
            },
        ];
    }
    getBody() {
        return dedent `
      ${this.data.asBinary ? 'Read as Binary' : 'Read as Text'}
      ${this.data.usePathInput ? '' : `Path: ${this.data.path}`}
    `;
    }
    async process(inputData, context) {
        const { nativeApi } = context;
        if (nativeApi == null) {
            throw new Error('This node requires a native API to run.');
        }
        const path = getInputOrData(this.chartNode.data, inputData, 'path');
        try {
            if (this.data.asBinary) {
                const content = await nativeApi.readBinaryFile(path);
                const buffer = await content.arrayBuffer();
                return {
                    ['content']: { type: 'binary', value: new Uint8Array(buffer) },
                };
            }
            else {
                const content = await nativeApi.readTextFile(path, undefined);
                return {
                    ['content']: { type: 'string', value: content },
                };
            }
        }
        catch (err) {
            if (this.chartNode.data.errorOnMissingFile) {
                throw err;
            }
            else {
                return {
                    ['content']: { type: 'control-flow-excluded', value: undefined },
                };
            }
        }
    }
}
export const readFileNode = nodeDefinition(ReadFileNodeImpl, 'Read File');
