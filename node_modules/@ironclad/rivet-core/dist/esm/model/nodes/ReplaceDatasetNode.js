import { NodeImpl } from '../NodeImpl.js';
import { nanoid } from 'nanoid/non-secure';
import { dedent } from 'ts-dedent';
import { nodeDefinition } from '../NodeDefinition.js';
import { getInputOrData, coerceType, newId, inferType } from '../../utils/index.js';
import { arrayizeDataValue, unwrapDataValue } from '../DataValue.js';
export class ReplaceDatasetNodeImpl extends NodeImpl {
    static create() {
        return {
            id: nanoid(),
            type: 'replaceDataset',
            title: 'Replace Dataset',
            visualData: { x: 0, y: 0, width: 250 },
            data: {
                datasetId: '',
            },
        };
    }
    getInputDefinitions() {
        const inputDefinitions = [];
        inputDefinitions.push({
            id: 'data',
            dataType: 'object[]',
            title: 'Data',
            description: 'The new data of the dataset. If empty, the dataset will be cleared. May be an array of array of strings, or an array of DatasetRow objects with { id, data } properties. If a string[][], IDs will be generated.',
        });
        if (this.data.useDatasetIdInput) {
            inputDefinitions.push({
                id: 'datasetId',
                title: 'Dataset ID',
                dataType: 'string',
                description: 'The ID of the dataset to replace.',
            });
        }
        return inputDefinitions;
    }
    getOutputDefinitions() {
        return [
            {
                id: 'dataset',
                title: 'Dataset',
                dataType: 'object[]',
                description: 'The new data of the dataset. An array of DatasetRow objects with { id, data } properties.',
            },
        ];
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Replaces the data in a dataset with the given data. If no data is given, the dataset will be cleared instead.
      `,
            infoBoxTitle: 'Replace Dataset Node',
            contextMenuTitle: 'Replace Dataset',
            group: ['Input/Output'],
        };
    }
    getEditors() {
        return [
            {
                type: 'datasetSelector',
                label: 'Dataset',
                dataKey: 'datasetId',
                useInputToggleDataKey: 'useDatasetIdInput',
            },
        ];
    }
    async process(inputs, context) {
        const { datasetProvider } = context;
        if (datasetProvider == null) {
            throw new Error('datasetProvider is required');
        }
        const datasetId = getInputOrData(this.data, inputs, 'datasetId', 'string');
        const dataInput = inputs['data'];
        if (!dataInput) {
            await datasetProvider.putDatasetData(datasetId, { id: datasetId, rows: [] });
            return {
                ['dataset']: {
                    type: 'object[]',
                    value: [],
                },
            };
        }
        let dataArrays = unwrapDataValue(dataInput).value;
        if (!Array.isArray(dataArrays)) {
            throw new Error('Data input must be either an array of rows, or an array of columns for a single row.');
        }
        const isDatasetRow = (row) => {
            return typeof row === 'object' && row != null && 'id' in row && 'data' in row;
        };
        const firstElem = dataArrays[0];
        if (!Array.isArray(firstElem) && !isDatasetRow(firstElem)) {
            dataArrays = [dataArrays];
        }
        const rows = dataArrays.map((row) => {
            if (Array.isArray(row)) {
                return {
                    id: newId(),
                    data: row.map((value) => coerceType(inferType(value), 'string')),
                };
            }
            if ('id' in row && 'data' in row) {
                return row;
            }
            throw new Error('Data input must be an array of strings or DatasetRows');
        });
        await datasetProvider.putDatasetData(datasetId, {
            id: datasetId,
            rows,
        });
        return {
            ['dataset']: {
                type: 'object[]',
                value: rows,
            },
        };
    }
}
export const replaceDatasetNode = nodeDefinition(ReplaceDatasetNodeImpl, 'Replace Dataset');
