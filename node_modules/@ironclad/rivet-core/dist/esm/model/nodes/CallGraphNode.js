import {} from '../NodeBase.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import { nanoid } from 'nanoid/non-secure';
import {} from '../ProcessContext.js';
import { dedent } from 'ts-dedent';
import { coerceTypeOptional } from '../../utils/coerceType.js';
import { looseDataValuesToDataValues } from '../../api/looseDataValue.js';
import { getError } from '../../utils/errors.js';
export class CallGraphNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'callGraph',
            title: 'Call Graph',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 200,
            },
            data: {
                useErrorOutput: false,
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        const inputs = [];
        inputs.push({
            id: 'graph',
            dataType: 'graph-reference',
            title: 'Graph',
            description: 'The reference to the graph to call.',
            required: true,
        });
        inputs.push({
            id: 'inputs',
            dataType: 'object',
            title: 'Inputs',
            description: 'The inputs to pass to the graph. Should be an object where the keys are the input names and the values are the input values.',
        });
        return inputs;
    }
    getOutputDefinitions() {
        const outputs = [
            {
                id: 'outputs',
                dataType: 'object',
                title: 'Outputs',
                description: 'The outputs of the graph.',
            },
        ];
        if (this.data.useErrorOutput) {
            outputs.push({
                id: 'error',
                dataType: 'string',
                title: 'Error',
                description: 'The error message if the graph call failed.',
            });
        }
        return outputs;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Calls another graph and passes inputs to it. Use in combination with the Graph Reference node to call dynamic graphs.
      `,
            infoBoxTitle: 'Call Graph Node',
            contextMenuTitle: 'Call Graph',
            group: ['Advanced'],
        };
    }
    async process(inputs, context) {
        const graphRef = coerceTypeOptional(inputs['graph'], 'graph-reference');
        const graphInputs = coerceTypeOptional(inputs['inputs'], 'object');
        if (!graphRef) {
            return {
                ['outputs']: {
                    type: 'control-flow-excluded',
                    value: undefined,
                },
            };
        }
        const graph = context.project.graphs[graphRef.graphId];
        if (!graph) {
            return {
                ['outputs']: {
                    type: 'control-flow-excluded',
                    value: undefined,
                },
            };
        }
        const subGraphProcessor = context.createSubProcessor(graphRef.graphId, { signal: context.signal });
        const outputs = {};
        try {
            const startTime = Date.now();
            const inputData = looseDataValuesToDataValues(graphInputs);
            const graphOutputs = await subGraphProcessor.processGraph(context, inputData, context.contextValues);
            const duration = Date.now() - startTime;
            outputs['outputs'] = {
                type: 'object',
                value: graphOutputs,
            };
            if (this.data.useErrorOutput) {
                outputs['error'] = {
                    type: 'control-flow-excluded',
                    value: undefined,
                };
            }
            if (outputs['duration'] == null) {
                outputs['duration'] = {
                    type: 'number',
                    value: duration,
                };
            }
            return outputs;
        }
        catch (err) {
            if (!this.data.useErrorOutput) {
                throw err;
            }
            outputs['outputs'] = {
                type: 'control-flow-excluded',
                value: undefined,
            };
            outputs['error'] = {
                type: 'string',
                value: getError(err).message,
            };
            return outputs;
        }
    }
}
export const callGraphNode = nodeDefinition(CallGraphNodeImpl, 'Call Graph');
