import {} from '../NodeBase.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import {} from '../NodeGraph.js';
import { nanoid } from 'nanoid/non-secure';
import {} from '../ProcessContext.js';
import {} from '../../index.js';
import { dedent } from 'ts-dedent';
import { coerceType } from '../../utils/index.js';
export class GraphReferenceNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'graphReference',
            title: 'Graph Reference',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 275,
            },
            data: {
                graphId: '',
                useGraphIdOrNameInput: false,
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        const inputs = [];
        if (this.data.useGraphIdOrNameInput) {
            inputs.push({
                id: 'graph-name-or-id',
                dataType: 'string',
                title: 'Graph Name Or ID',
                description: 'The name or ID of the graph to get a reference to.',
                required: true,
            });
        }
        return inputs;
    }
    getOutputDefinitions() {
        return [
            {
                id: 'graph',
                dataType: 'graph-reference',
                title: 'Graph',
                description: 'A reference to the graph.',
            },
        ];
    }
    getEditors() {
        const definitions = [
            {
                type: 'graphSelector',
                label: 'Graph',
                dataKey: 'graphId',
                useInputToggleDataKey: 'useGraphIdOrNameInput',
            },
        ];
        return definitions;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Gets a reference to another graph, that can be used to pass around graphs to call using a Call Graph node.
      `,
            infoBoxTitle: 'Graph Reference Node',
            contextMenuTitle: 'Graph Reference',
            group: ['Advanced'],
        };
    }
    getBody(context) {
        if (this.data.useGraphIdOrNameInput) {
            return '(Graph from input)';
        }
        const graph = context.project.graphs[this.data.graphId];
        if (!graph) {
            return '(Graph not found)';
        }
        return graph.metadata.name ?? '(Unnamed Graph)';
    }
    async process(inputs, context) {
        if (this.data.useGraphIdOrNameInput) {
            const graphIdOrName = coerceType(inputs['graph-name-or-id'], 'string');
            let graph = context.project.graphs[graphIdOrName];
            if (!graph) {
                graph = Object.values(context.project.graphs).find((graph) => graph.metadata.name === graphIdOrName);
            }
            if (!graph) {
                return {
                    ['graph']: {
                        type: 'control-flow-excluded',
                        value: undefined,
                    },
                };
            }
            return {
                ['graph']: {
                    type: 'graph-reference',
                    value: {
                        graphId: graph.metadata.id ?? '',
                        graphName: graph.metadata.name ?? '',
                    },
                },
            };
        }
        const graph = context.project.graphs[this.data.graphId];
        if (!graph) {
            return {
                ['graph']: {
                    type: 'control-flow-excluded',
                    value: undefined,
                },
            };
        }
        return {
            ['graph']: {
                type: 'graph-reference',
                value: {
                    graphId: graph.metadata.id ?? '',
                    graphName: graph.metadata.name ?? '',
                },
            },
        };
    }
}
export const graphReferenceNode = nodeDefinition(GraphReferenceNodeImpl, 'Graph Reference');
