import { nanoid } from 'nanoid';
import { NodeImpl } from '../NodeImpl.js';
import { dedent } from 'ts-dedent';
import { nodeDefinition } from '../NodeDefinition.js';
import { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';
export class DelegateFunctionCallNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'delegateFunctionCall',
            title: 'Delegate Function Call',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 325,
            },
            data: {
                handlers: [],
                unknownHandler: undefined,
            },
        };
        return chartNode;
    }
    getInputDefinitions() {
        const inputs = [];
        inputs.push({
            id: 'function-call',
            dataType: 'object',
            title: 'Function Call',
            coerced: true,
            required: true,
            description: 'The function call to delegate to a subgraph.',
        });
        return inputs;
    }
    getOutputDefinitions() {
        const outputs = [];
        outputs.push({
            id: 'output',
            dataType: 'string',
            title: 'Output',
            description: 'The output of the function call.',
        });
        outputs.push({
            id: 'message',
            dataType: 'object',
            title: 'Message Output',
            description: 'Maps the output for use directly with an Assemble Prompt node and GPT.',
        });
        return outputs;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Handles a function call by delegating it to a different subgraph depending on the function call.
      `,
            infoBoxTitle: 'Delegate Function Call Node',
            contextMenuTitle: 'Delegate Function Call',
            group: ['Advanced'],
        };
    }
    getEditors() {
        return [
            {
                type: 'custom',
                customEditorId: 'ToolCallHandlers',
                label: 'Handlers',
                dataKey: 'handlers',
            },
            {
                type: 'graphSelector',
                dataKey: 'unknownHandler',
                label: 'Unknown Handler',
                helperMessage: 'The subgraph to delegate to if the function call does not match any handlers.',
            },
        ];
    }
    getBody(context) {
        if (this.data.handlers.length === 0) {
            return 'No handlers defined';
        }
        const lines = ['Handlers:'];
        this.data.handlers.forEach(({ key, value }) => {
            const subgraphName = context.project.graphs[value]?.metadata.name ?? 'Unknown Subgraph';
            lines.push(`    ${key || '(MISSING!)'} -> ${subgraphName}`);
        });
        return lines.join('\n');
    }
    async process(inputs, context) {
        const functionCall = coerceType(inputs['function-call'], 'object');
        let handler = this.data.handlers.find((handler) => handler.key === functionCall.name);
        if (!handler) {
            if (this.data.unknownHandler) {
                handler = { key: undefined, value: this.data.unknownHandler };
            }
            else {
                throw new Error(`No handler found for function call: ${functionCall.name}`);
            }
        }
        const subgraphInputs = {
            _function_name: {
                type: 'string',
                value: functionCall.name,
            },
            _arguments: {
                type: 'object',
                value: functionCall.arguments,
            },
        };
        for (const [argName, argument] of Object.entries(functionCall.arguments)) {
            subgraphInputs[argName] = {
                type: 'any',
                value: argument,
            };
        }
        const handlerGraphId = handler.value;
        const subprocessor = context.createSubProcessor(handlerGraphId, { signal: context.signal });
        const outputs = await subprocessor.processGraph(context, subgraphInputs, context.contextValues);
        const outputString = coerceTypeOptional(outputs.output, 'string') ?? '';
        return {
            ['output']: {
                type: 'string',
                value: outputString,
            },
            ['message']: {
                type: 'chat-message',
                value: {
                    type: 'function',
                    message: outputString,
                    name: functionCall.id ?? '',
                },
            },
        };
    }
}
export const delegateFunctionCallNode = nodeDefinition(DelegateFunctionCallNodeImpl, 'Delegate Function Call');
