import { max, range, sum, uniqBy } from 'lodash-es';
import { isArrayDataValue, arrayizeDataValue, getScalarTypeOf, } from './DataValue.js';
import { IF_PORT, } from './NodeBase.js';
import PQueueImport from 'p-queue';
import { getError } from '../utils/errors.js';
import Emittery from 'emittery';
import { entries, fromEntries, values } from '../utils/typeSafety.js';
import { isNotNull } from '../utils/genericUtilFunctions.js';
import { nanoid } from 'nanoid/non-secure';
import { P, match } from 'ts-pattern';
import { coerceTypeOptional } from '../utils/coerceType.js';
import { globalRivetNodeRegistry } from './Nodes.js';
import { getPluginConfig } from '../utils/index.js';
import { GptTokenizerTokenizer } from '../integrations/GptTokenizerTokenizer.js';
// CJS compatibility, gets default.default for whatever reason
let PQueue = PQueueImport;
if (typeof PQueue !== 'function') {
    PQueue = PQueueImport.default;
}
export class GraphProcessor {
    // Per-instance state
    #graph;
    #project;
    #nodesById;
    #nodeInstances;
    #connections;
    #definitions;
    #emitter = new Emittery();
    #running = false;
    #isSubProcessor = false;
    #scc;
    #nodesNotInCycle;
    #externalFunctions = {};
    slowMode = false;
    #isPaused = false;
    #parent;
    #registry;
    id = nanoid();
    #includeTrace = true;
    executor;
    /** If set, specifies the node(s) that the graph will run TO, instead of the nodes without any dependents. */
    runToNodeIds;
    /** If set, specifies the node that the graph will run FROM, instead of the start nodes. Requires preloading data. */
    runFromNodeId;
    /** The node that is executing this graph, almost always a subgraph node. Undefined for root. */
    #executor;
    /** The interval between nodeFinish events when playing back a recording. I.e. how fast the playback is. */
    recordingPlaybackChatLatency = 1000;
    warnOnInvalidGraph = false;
    // Per-process state
    #erroredNodes = undefined;
    #remainingNodes = undefined;
    #visitedNodes = undefined;
    #currentlyProcessing = undefined;
    #context = undefined;
    #nodeResults = undefined;
    #abortController = undefined;
    #processingQueue = undefined;
    #graphInputs = undefined;
    #graphOutputs = undefined;
    #executionCache = undefined;
    #queuedNodes = undefined;
    #loopControllersSeen = undefined;
    #subprocessors = undefined;
    #contextValues = undefined;
    #globals = undefined;
    #attachedNodeData = undefined;
    #aborted = false;
    #abortSuccessfully = false;
    #abortError = undefined;
    #totalCost = 0;
    #ignoreNodes = undefined;
    #hasPreloadedData = false;
    #nodeAbortControllers = new Map();
    /** User input nodes that are pending user input. */
    #pendingUserInputs = undefined;
    get isRunning() {
        return this.#running;
    }
    constructor(project, graphId, registry, includeTrace) {
        this.#project = project;
        const graph = graphId
            ? project.graphs[graphId]
            : project.metadata.mainGraphId
                ? project.graphs[project.metadata.mainGraphId]
                : undefined;
        if (!graph) {
            throw new Error(`Graph ${graphId} not found in project`);
        }
        this.#graph = graph;
        this.#includeTrace = includeTrace;
        this.#nodeInstances = {};
        this.#connections = {};
        this.#nodesById = {};
        this.#registry = registry ?? globalRivetNodeRegistry;
        this.#emitter.bindMethods(this, ['on', 'off', 'once', 'onAny', 'offAny']);
        // Create node instances and store them in a lookup table
        for (const node of this.#graph.nodes) {
            this.#nodeInstances[node.id] = this.#registry.createDynamicImpl(node);
            this.#nodesById[node.id] = node;
        }
        // Store connections in a lookup table
        for (const conn of this.#graph.connections) {
            if (!this.#nodesById[conn.inputNodeId] || !this.#nodesById[conn.outputNodeId]) {
                if (this.warnOnInvalidGraph) {
                    if (!this.#nodesById[conn.inputNodeId]) {
                        console.warn(`Missing node ${conn.inputNodeId} in graph ${graphId} (connection from ${this.#nodesById[conn.outputNodeId]?.title})`);
                    }
                    else {
                        console.warn(`Missing node ${conn.outputNodeId} in graph ${graphId} (connection to ${this.#nodesById[conn.inputNodeId]?.title}) `);
                    }
                }
                continue;
            }
            this.#connections[conn.inputNodeId] ??= [];
            this.#connections[conn.outputNodeId] ??= [];
            this.#connections[conn.inputNodeId].push(conn);
            this.#connections[conn.outputNodeId].push(conn);
        }
        // Store input and output definitions in a lookup table
        this.#definitions = {};
        for (const node of this.#graph.nodes) {
            const connectionsForNode = this.#connections[node.id] ?? [];
            const inputDefs = this.#nodeInstances[node.id].getInputDefinitionsIncludingBuiltIn(connectionsForNode, this.#nodesById, this.#project);
            const outputDefs = this.#nodeInstances[node.id].getOutputDefinitions(connectionsForNode, this.#nodesById, this.#project);
            this.#definitions[node.id] = { inputs: inputDefs, outputs: outputDefs };
            // Find all invalid connections to or from the node, then remove them from consideration
            const invalidConnections = connectionsForNode.filter((connection) => {
                if (connection.inputNodeId === node.id) {
                    const inputDef = inputDefs.find((def) => def.id === connection.inputId);
                    if (!inputDef) {
                        if (this.warnOnInvalidGraph) {
                            const nodeFrom = this.#nodesById[connection.outputNodeId];
                            console.warn(`[Warn] Invalid connection going from "${nodeFrom?.title}".${connection.outputId} to "${node.title}".${connection.inputId}`);
                        }
                        return true;
                    }
                }
                else {
                    const outputDef = outputDefs.find((def) => def.id === connection.outputId);
                    if (!outputDef) {
                        if (this.warnOnInvalidGraph) {
                            const nodeTo = this.#nodesById[connection.inputNodeId];
                            console.warn(`[Warn] Invalid connection going from "${node.title}".${connection.outputId} to "${nodeTo?.title}".${connection.inputId}`);
                        }
                        return true;
                    }
                }
                return false;
            });
            for (const connections of values(this.#connections)) {
                for (const invalidConnection of invalidConnections) {
                    const index = connections.indexOf(invalidConnection);
                    if (index !== -1) {
                        connections.splice(index, 1);
                    }
                }
            }
        }
        this.#scc = this.#tarjanSCC();
        this.#nodesNotInCycle = this.#scc.filter((cycle) => cycle.length === 1).flat();
        this.setExternalFunction('echo', async (value) => ({ type: 'any', value }));
        this.#emitter.on('globalSet', ({ id, value }) => {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit(`globalSet:${id}`, value);
        });
    }
    #emitTraceEvent(eventData) {
        if (this.#includeTrace) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('trace', eventData);
        }
    }
    on = undefined;
    off = undefined;
    once = undefined;
    onAny = undefined;
    offAny = undefined;
    #onUserEventHandlers = new Map();
    onUserEvent(onEvent, listener) {
        const handler = (event, value) => {
            if (event === `userEvent:${onEvent}`) {
                listener(value);
            }
        };
        this.#onUserEventHandlers.set(listener, handler);
        this.#emitter.onAny(handler);
    }
    offUserEvent(listener) {
        const internalHandler = this.#onUserEventHandlers.get(listener);
        this.#emitter.offAny(internalHandler);
    }
    userInput(nodeId, values) {
        const pending = this.#pendingUserInputs[nodeId];
        if (pending) {
            pending.resolve(values);
            delete this.#pendingUserInputs[nodeId];
        }
        for (const processor of this.#subprocessors) {
            processor.userInput(nodeId, values);
        }
    }
    setExternalFunction(name, fn) {
        this.#externalFunctions[name] = fn;
    }
    async abort(successful = false, error) {
        if (!this.#running || this.#aborted) {
            return Promise.resolve();
        }
        this.#abortController.abort();
        this.#abortSuccessfully = successful;
        this.#abortError = error;
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('graphAbort', { successful, error, graph: this.#graph });
        if (!this.#isSubProcessor) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('abort', { successful, error });
        }
        await this.#processingQueue.onIdle();
    }
    pause() {
        if (this.#isPaused === false) {
            this.#isPaused = true;
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('pause', void 0);
        }
    }
    resume() {
        if (this.#isPaused) {
            this.#isPaused = false;
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('resume', void 0);
        }
    }
    setSlowMode(slowMode) {
        this.slowMode = slowMode;
    }
    async #waitUntilUnpaused() {
        if (!this.#isPaused) {
            return;
        }
        await this.#emitter.once('resume');
    }
    async *events() {
        for await (const [event, data] of this.#emitter.anyEvent()) {
            yield { type: event, ...data };
            if (event === 'finish') {
                break;
            }
        }
    }
    preloadNodeData(nodeId, data) {
        this.#nodeResults ??= new Map();
        this.#visitedNodes ??= new Set();
        for (const value of Object.values(data)) {
            if (!value || !('type' in value) || !value.type) {
                throw new Error(`Invalid data value for node ${nodeId}, must be a DataValue`);
            }
        }
        this.#nodeResults.set(nodeId, data);
        this.#visitedNodes.add(nodeId);
        this.#hasPreloadedData = true;
    }
    /** Gets all node IDs that a given node ID depends on being complete before the given node ID can start. */
    getDependencyNodesDeep(nodeId) {
        const node = this.#nodesById[nodeId];
        if (!node) {
            return [];
        }
        const connections = this.#connections[nodeId];
        if (!connections) {
            return [];
        }
        const dependencyNodes = connections
            .map((conn) => {
            if (conn.inputNodeId === nodeId) {
                return this.getDependencyNodesDeep(conn.outputNodeId);
            }
            return [];
        })
            .flat();
        return [...new Set([nodeId, ...dependencyNodes])];
    }
    async replayRecording(recorder) {
        const { events } = recorder;
        this.#initProcessState();
        try {
            const nodesByIdAllGraphs = {};
            for (const graph of Object.values(this.#project.graphs)) {
                for (const node of graph.nodes) {
                    nodesByIdAllGraphs[node.id] = node;
                }
            }
            const getGraph = (graphId) => {
                const graph = this.#project.graphs[graphId];
                if (!graph) {
                    throw new Error(`Mismatch between project and recording: graph ${graphId} not found in project`);
                }
                return graph;
            };
            const getNode = (nodeId) => {
                const node = nodesByIdAllGraphs[nodeId];
                if (!node) {
                    throw new Error(`Mismatch between project and recording: node ${nodeId} not found in any graph in project`);
                }
                return node;
            };
            for (const event of events) {
                if (this.#aborted) {
                    break;
                }
                await this.#waitUntilUnpaused();
                await match(event)
                    .with({ type: 'start' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('start', {
                        project: this.#project,
                        contextValues: data.contextValues,
                        inputs: data.inputs,
                        startGraph: getGraph(data.startGraph),
                    });
                    this.#contextValues = data.contextValues;
                    this.#graphInputs = data.inputs;
                })
                    .with({ type: 'abort' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('abort', data);
                })
                    .with({ type: 'pause' }, () => { })
                    .with({ type: 'resume' }, () => { })
                    .with({ type: 'done' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('done', data);
                    this.#graphOutputs = data.results;
                    this.#running = false;
                })
                    .with({ type: 'error' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('error', data);
                })
                    .with({ type: 'globalSet' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('globalSet', data);
                })
                    .with({ type: 'trace' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('trace', data);
                })
                    .with({ type: 'graphStart' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('graphStart', {
                        graph: getGraph(data.graphId),
                        inputs: data.inputs,
                    });
                })
                    .with({ type: 'graphFinish' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('graphFinish', {
                        graph: getGraph(data.graphId),
                        outputs: data.outputs,
                    });
                })
                    .with({ type: 'graphError' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('graphError', {
                        graph: getGraph(data.graphId),
                        error: data.error,
                    });
                })
                    .with({ type: 'graphAbort' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('graphAbort', {
                        graph: getGraph(data.graphId),
                        error: data.error,
                        successful: data.successful,
                    });
                })
                    .with({ type: 'nodeStart' }, async ({ data }) => {
                    const node = getNode(data.nodeId);
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('nodeStart', {
                        node: getNode(data.nodeId),
                        inputs: data.inputs,
                        processId: data.processId,
                    });
                    // Every time a chat node starts, we wait for the playback interval
                    if (node.type === 'chat') {
                        await new Promise((resolve) => setTimeout(resolve, this.recordingPlaybackChatLatency));
                    }
                })
                    .with({ type: 'nodeFinish' }, ({ data }) => {
                    const node = getNode(data.nodeId);
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('nodeFinish', {
                        node,
                        outputs: data.outputs,
                        processId: data.processId,
                    });
                    this.#nodeResults.set(data.nodeId, data.outputs);
                    this.#visitedNodes.add(data.nodeId);
                })
                    .with({ type: 'nodeError' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('nodeError', {
                        node: getNode(data.nodeId),
                        error: data.error,
                        processId: data.processId,
                    });
                    this.#erroredNodes.set(data.nodeId, data.error);
                    this.#visitedNodes.add(data.nodeId);
                })
                    .with({ type: 'nodeExcluded' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('nodeExcluded', {
                        node: getNode(data.nodeId),
                        processId: data.processId,
                        inputs: data.inputs,
                        outputs: data.outputs,
                        reason: data.reason,
                    });
                    this.#visitedNodes.add(data.nodeId);
                })
                    .with({ type: 'nodeOutputsCleared' }, () => { })
                    .with({ type: 'partialOutput' }, () => { })
                    .with({ type: 'userInput' }, ({ data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('userInput', {
                        callback: undefined,
                        inputStrings: data.inputStrings,
                        inputs: data.inputs,
                        node: getNode(data.nodeId),
                        processId: data.processId,
                        renderingType: data.renderingType,
                    });
                })
                    .with({ type: P.string.startsWith('globalSet:') }, ({ type, data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit(type, data);
                })
                    .with({ type: P.string.startsWith('userEvent:') }, ({ type, data }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit(type, data);
                })
                    .with({ type: 'newAbortController' }, () => { })
                    .with({ type: 'finish' }, () => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('finish', undefined);
                })
                    .with(P.nullish, () => { })
                    .exhaustive();
            }
        }
        catch (err) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('error', { error: getError(err) });
        }
        finally {
            this.#running = false;
        }
        return this.#graphOutputs;
    }
    #initProcessState() {
        this.#running = true;
        if (!this.#hasPreloadedData) {
            this.#nodeResults = new Map();
            this.#visitedNodes = new Set();
        }
        this.#erroredNodes = new Map();
        this.#currentlyProcessing = new Set();
        this.#remainingNodes = new Set(this.#graph.nodes.map((n) => n.id));
        this.#pendingUserInputs = {};
        this.#processingQueue = new PQueue({ concurrency: Infinity });
        this.#graphOutputs = {};
        this.#executionCache ??= new Map();
        this.#queuedNodes = new Set();
        this.#loopControllersSeen = new Set();
        this.#subprocessors = new Set();
        this.#attachedNodeData = new Map();
        this.#globals ??= new Map();
        this.#ignoreNodes = new Set();
        this.#abortController = this.#newAbortController();
        this.#abortController.signal.addEventListener('abort', () => {
            this.#aborted = true;
        });
        this.#aborted = false;
        this.#abortError = undefined;
        this.#abortSuccessfully = false;
        this.#nodeAbortControllers = new Map();
    }
    /** Main function for running a graph. Runs a graph and returns the outputs from the output nodes of the graph. */
    async processGraph(
    /** Required and optional context available to the nodes and all subgraphs. */
    context, 
    /** Inputs to the main graph. You should pass all inputs required by the GraphInputNodes of the graph. */
    inputs = {}, 
    /** Contextual data available to all graphs and subgraphs. Kind of like react context, avoids drilling down data into subgraphs. Be careful when using it. */
    contextValues = {}) {
        try {
            if (this.#running) {
                throw new Error('Cannot process graph while already processing');
            }
            this.#initProcessState();
            this.#context = context;
            this.#graphInputs = inputs;
            this.#contextValues ??= contextValues;
            if (this.#context.tokenizer) {
                this.#context.tokenizer.on('error', (error) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('error', { error });
                });
            }
            if (!this.#isSubProcessor) {
                await this.#emitter.emit('start', {
                    contextValues: this.#contextValues,
                    inputs: this.#graphInputs,
                    project: this.#project,
                    startGraph: this.#graph,
                });
            }
            await this.#emitter.emit('graphStart', { graph: this.#graph, inputs: this.#graphInputs });
            if (this.#hasPreloadedData) {
                for (const node of this.#graph.nodes) {
                    if (this.#nodeResults.has(node.id)) {
                        this.#emitTraceEvent(`Node ${node.title} has preloaded data`);
                        await this.#emitter.emit('nodeStart', {
                            node,
                            inputs: {},
                            processId: 'preload',
                        });
                        await this.#emitter.emit('nodeFinish', {
                            node,
                            outputs: this.#nodeResults.get(node.id),
                            processId: 'preload',
                        });
                    }
                }
            }
            const startNodes = this.runToNodeIds
                ? this.#graph.nodes.filter((node) => this.runToNodeIds?.includes(node.id))
                : this.#graph.nodes.filter((node) => this.#outputNodesFrom(node).nodes.length === 0);
            await this.#waitUntilUnpaused();
            for (const startNode of startNodes) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.#processingQueue.add(async () => {
                    await this.#fetchNodeDataAndProcessNode(startNode);
                });
            }
            await this.#processingQueue.onIdle();
            // Anything not queued at this phase here should be ignored
            if (this.runToNodeIds) {
                // For safety, we'll only activate this if runToNodeIds is set, in case there are bugs in the first pass
                for (const node of this.#graph.nodes) {
                    if (this.#queuedNodes.has(node.id) === false) {
                        this.#ignoreNodes.add(node.id);
                    }
                }
            }
            // If we've aborted successfully, we can treat the graph like it succeeded
            const erroredNodes = [...this.#erroredNodes.entries()].filter(([nodeId]) => {
                const erroredNodeAttachedData = this.#getAttachedDataTo(nodeId);
                return erroredNodeAttachedData.races == null || erroredNodeAttachedData.races.completed === false;
            });
            if (erroredNodes.length && !this.#abortSuccessfully) {
                const error = this.#abortError ??
                    Error(`Graph ${this.#graph.metadata.name} (${this.#graph.metadata.id}) failed to process due to errors in nodes: ${erroredNodes
                        .map(([nodeId, error]) => `${this.#nodesById[nodeId].title} (${nodeId}): ${error}`)
                        .join(', ')}`);
                await this.#emitter.emit('graphError', { graph: this.#graph, error });
                if (!this.#isSubProcessor) {
                    await this.#emitter.emit('error', { error });
                }
                throw error;
            }
            if (this.#graphOutputs['cost'] == null) {
                this.#graphOutputs['cost'] = {
                    type: 'number',
                    value: this.#totalCost,
                };
            }
            const outputValues = this.#graphOutputs;
            this.#running = false;
            await this.#emitter.emit('graphFinish', { graph: this.#graph, outputs: outputValues });
            if (!this.#isSubProcessor) {
                await this.#emitter.emit('done', { results: outputValues });
                await this.#emitter.emit('finish', undefined);
            }
            return outputValues;
        }
        finally {
            this.#running = false;
            if (!this.#isSubProcessor) {
                await this.#emitter.emit('finish', undefined);
            }
        }
    }
    async #fetchNodeDataAndProcessNode(node) {
        if (this.#currentlyProcessing.has(node.id) || this.#queuedNodes.has(node.id)) {
            return;
        }
        if (this.#nodeResults.has(node.id) || this.#erroredNodes.has(node.id)) {
            return;
        }
        const inputNodes = this.#inputNodesTo(node);
        // Check if all input nodes are free of errors
        for (const inputNode of inputNodes) {
            if (this.#erroredNodes.has(inputNode.id)) {
                return;
            }
        }
        // Check if all required inputs have connections and if the connected output nodes have been visited
        const connections = this.#connections[node.id] ?? [];
        const inputsReady = this.#definitions[node.id].inputs.every((input) => {
            const connectionToInput = connections?.find((conn) => conn.inputId === input.id && conn.inputNodeId === node.id);
            return connectionToInput || !input.required;
        });
        if (!inputsReady) {
            return;
        }
        this.#emitTraceEvent(`Node ${node.title} has required inputs nodes: ${inputNodes.map((n) => n.title).join(', ')}`);
        const attachedData = this.#getAttachedDataTo(node);
        if (node.type === 'raceInputs' || attachedData.races) {
            for (const inputNode of inputNodes) {
                const inputNodeAttachedData = this.#getAttachedDataTo(inputNode);
                const raceIds = new Set([...(attachedData.races?.raceIds ?? [])]);
                if (node.type === 'raceInputs') {
                    raceIds.add(`race-${node.id}`);
                }
                inputNodeAttachedData.races = {
                    propagate: false,
                    raceIds: [...raceIds],
                    completed: false,
                };
            }
        }
        this.#queuedNodes.add(node.id);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#processingQueue.addAll(inputNodes.map((inputNode) => {
            return async () => {
                this.#emitTraceEvent(`Fetching required data for node ${inputNode.title} (${inputNode.id})`);
                await this.#fetchNodeDataAndProcessNode(inputNode);
            };
        }));
        await this.#processNodeIfAllInputsAvailable(node);
    }
    /** If all inputs are present, all conditions met, processes the node. */
    async #processNodeIfAllInputsAvailable(node) {
        const builtInNode = node;
        if (this.#ignoreNodes.has(node.id)) {
            this.#emitTraceEvent(`Node ${node.title} is ignored`);
            return;
        }
        if (this.runToNodeIds) {
            const dependencyNodes = this.getDependencyNodesDeep(node.id);
            if (this.runToNodeIds.some((runTo) => runTo !== node.id && dependencyNodes.includes(runTo))) {
                this.#emitTraceEvent(`Node ${node.title} is excluded due to runToNodeIds`);
                return;
            }
        }
        if (this.#currentlyProcessing.has(node.id)) {
            this.#emitTraceEvent(`Node ${node.title} is already being processed`);
            return;
        }
        // For a loop controller, it can run multiple times, otherwise we already processed this node so bail out
        if (this.#visitedNodes.has(node.id) && node.type !== 'loopController') {
            this.#emitTraceEvent(`Node ${node.title} has already been processed`);
            return;
        }
        if (this.#erroredNodes.has(node.id)) {
            this.#emitTraceEvent(`Node ${node.title} has already errored`);
            return;
        }
        const inputNodes = this.#inputNodesTo(node);
        // Check if all input nodes are free of errors
        for (const inputNode of inputNodes) {
            if (this.#erroredNodes.has(inputNode.id)) {
                this.#emitTraceEvent(`Node ${node.title} has errored input node ${inputNode.title}`);
                return;
            }
        }
        // Check if all required inputs have connections and if the connected output nodes have been visited
        const connections = this.#connections[node.id] ?? [];
        const inputsReady = this.#definitions[node.id].inputs.every((input) => {
            const connectionToInput = connections?.find((conn) => conn.inputId === input.id && conn.inputNodeId === node.id);
            return connectionToInput || !input.required;
        });
        if (!inputsReady) {
            this.#emitTraceEvent(`Node ${node.title} has required inputs nodes: ${inputNodes.map((n) => n.title).join(', ')}`);
            return;
        }
        // Excluded because control flow is still in a loop - difference between "will not execute" and "has not executed yet"
        const inputValues = this.#getInputValuesForNode(node);
        if (this.#excludedDueToControlFlow(node, inputValues, nanoid(), 'loop-not-broken')) {
            this.#emitTraceEvent(`Node ${node.title} is excluded due to control flow`);
            return;
        }
        let waitingForInputNode = false;
        const anyInputIsValid = Object.values(inputValues).some((value) => value && value.type.includes('control-flow-excluded') === false);
        for (const inputNode of inputNodes) {
            // For loop controllers, allow nodes in the same cycle to be not processed yet,
            // but if we're in a 2nd iteration, we do need to wait for them
            if (node.type === 'loopController' &&
                !this.#loopControllersSeen.has(node.id) &&
                this.#nodesAreInSameCycle(node.id, inputNode.id)) {
                continue;
            }
            // Only one visited node required for a raceInputs node
            if (node.type === 'raceInputs' && this.#visitedNodes.has(inputNode.id) && anyInputIsValid) {
                waitingForInputNode = false;
                break;
            }
            if (waitingForInputNode === false && this.#visitedNodes.has(inputNode.id) === false) {
                waitingForInputNode = inputNode.title;
            }
        }
        if (waitingForInputNode) {
            this.#emitTraceEvent(`Node ${node.title} is waiting for input node ${waitingForInputNode}`);
            return;
        }
        this.#currentlyProcessing.add(node.id);
        if (node.type === 'loopController') {
            this.#loopControllersSeen.add(node.id);
        }
        const attachedData = this.#getAttachedDataTo(node);
        if (attachedData.loopInfo && attachedData.loopInfo.loopControllerId !== node.id) {
            attachedData.loopInfo.nodes.add(node.id);
        }
        if (attachedData.races?.completed) {
            this.#emitTraceEvent(`Node ${node.title} is part of a race that was completed`);
            return;
        }
        const processId = await this.#processNode(node);
        if (this.slowMode) {
            await new Promise((resolve) => setTimeout(resolve, 250));
        }
        this.#emitTraceEvent(`Finished processing node ${node.title} (${node.id})`);
        this.#visitedNodes.add(node.id);
        this.#currentlyProcessing.delete(node.id);
        this.#remainingNodes.delete(node.id);
        const outputNodes = this.#outputNodesFrom(node);
        // Aggressive - each iteration of the loop controller, we clear everything in the same cycle as the controller
        if (node.type === 'loopController') {
            const loopControllerResults = this.#nodeResults.get(node.id);
            // If the loop controller is excluded, we have to "break" it or else it'll loop forever...
            const breakValue = loopControllerResults['break'];
            const didBreak = 
            // @ts-ignore
            !(breakValue?.type === 'control-flow-excluded' && breakValue?.value === 'loop-not-broken') ??
                this.#excludedDueToControlFlow(node, this.#getInputValuesForNode(node), nanoid());
            if (!didBreak) {
                this.#emitTraceEvent(`Loop controller ${node.title} did not break, so we're looping again`);
                for (const loopNodeId of attachedData.loopInfo?.nodes ?? []) {
                    const cycleNode = this.#nodesById[loopNodeId];
                    this.#emitTraceEvent(`Clearing cycle node ${cycleNode.title} (${cycleNode.id})`);
                    this.#visitedNodes.delete(cycleNode.id);
                    this.#currentlyProcessing.delete(cycleNode.id);
                    this.#remainingNodes.add(cycleNode.id);
                    this.#nodeResults.delete(cycleNode.id);
                }
            }
        }
        // Abort everything the race depends on - everything already executed won't
        // be aborted, but everything that hasn't will be, effectively terminating all slower branches
        if (node.type === 'raceInputs') {
            const allNodesForRace = [...this.#attachedNodeData.entries()].filter(([, { races }]) => races?.raceIds.includes(`race-${node.id}`));
            for (const [nodeId] of allNodesForRace) {
                for (const [key, abortController] of this.#nodeAbortControllers.entries()) {
                    if (key.startsWith(nodeId)) {
                        this.#emitTraceEvent(`Aborting node ${nodeId} because other race branch won`);
                        abortController.abort();
                    }
                }
                // Mark every attached data as completed for the race
                for (const [, nodeAttachedData] of [...this.#attachedNodeData.entries()]) {
                    if (nodeAttachedData.races?.raceIds.includes(`race-${node.id}`)) {
                        nodeAttachedData.races.completed = true;
                    }
                }
            }
        }
        let childLoopInfo = attachedData.loopInfo;
        if (builtInNode.type === 'loopController') {
            if (childLoopInfo != null && childLoopInfo.loopControllerId !== builtInNode.id) {
                this.#nodeErrored(node, new Error('Nested loops are not supported'), processId);
                return;
            }
            childLoopInfo = {
                propagate: (parent, connectionsFromParent) => {
                    if (parent.type === 'loopController' &&
                        connectionsFromParent.some((c) => c.outputId === 'break')) {
                        return false;
                    }
                    return true;
                },
                loopControllerId: node.id,
                // We want to be able to clear every node that _potentially_ could run in the loop
                nodes: childLoopInfo?.nodes ?? new Set(),
                iterationCount: (childLoopInfo?.iterationCount ?? 0) + 1,
            };
            attachedData.loopInfo = childLoopInfo; // Not 100% sure if this is right - sets the childLoopInfo on the loop controller itself, probably fine?
        }
        for (const { node: outputNode, connections: connectionsToOutputNode } of outputNodes.connectionsToNodes) {
            const outputNodeAttachedData = this.#getAttachedDataTo(outputNode);
            const propagatedAttachedData = Object.entries(attachedData).filter(([, value]) => {
                if (!value) {
                    return false;
                }
                if (typeof value.propagate === 'boolean') {
                    return value.propagate;
                }
                return value.propagate(node, connectionsToOutputNode);
            });
            for (const [key, value] of propagatedAttachedData) {
                outputNodeAttachedData[key] = value;
            }
        }
        // Node is finished, check if we can run any more nodes that depend on this one
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#processingQueue.addAll(outputNodes.nodes.map((outputNode) => async () => {
            this.#emitTraceEvent(`Trying to run output node from ${node.title}: ${outputNode.title} (${outputNode.id})`);
            await this.#processNodeIfAllInputsAvailable(outputNode);
        }));
    }
    #getAttachedDataTo(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        let nodeData = this.#attachedNodeData.get(nodeId);
        if (nodeData == null) {
            nodeData = {};
            this.#attachedNodeData.set(nodeId, nodeData);
        }
        return nodeData;
    }
    async #processNode(node) {
        const processId = nanoid();
        if (this.#abortController.signal.aborted) {
            this.#nodeErrored(node, new Error('Processing aborted'), processId);
            return processId;
        }
        const inputNodes = this.#inputNodesTo(node);
        const erroredInputNodes = inputNodes.filter((inputNode) => this.#erroredNodes.has(inputNode.id));
        if (erroredInputNodes.length > 0) {
            const error = new Error(`Cannot process node ${node.title} (${node.id}) because it depends on errored nodes: ${erroredInputNodes
                .map((n) => `${n.title} (${n.id})`)
                .join(', ')}`);
            this.#nodeErrored(node, error, processId);
            return processId;
        }
        if (node.isSplitRun) {
            await this.#processSplitRunNode(node, processId);
        }
        else {
            await this.#processNormalNode(node, processId);
        }
        return processId;
    }
    async #processSplitRunNode(node, processId) {
        const inputValues = this.#getInputValuesForNode(node);
        if (this.#excludedDueToControlFlow(node, inputValues, processId)) {
            return;
        }
        const splittingAmount = Math.min(max(values(inputValues).map((value) => (Array.isArray(value?.value) ? value?.value.length : 1))) ?? 1, node.splitRunMax ?? 10);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('nodeStart', { node, inputs: inputValues, processId });
        try {
            let results = [];
            if (node.isSplitSequential) {
                for (let i = 0; i < splittingAmount; i++) {
                    if (this.#aborted) {
                        throw new Error('Processing aborted');
                    }
                    const inputs = fromEntries(entries(inputValues).map(([port, value]) => [
                        port,
                        isArrayDataValue(value) ? arrayizeDataValue(value)[i] ?? undefined : value,
                    ]));
                    try {
                        const output = await this.#processNodeWithInputData(node, inputs, i, processId, (node, partialOutputs, index) => {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            this.#emitter.emit('partialOutput', { node, outputs: partialOutputs, index, processId });
                        });
                        if (output['cost']?.type === 'number') {
                            this.#totalCost += coerceTypeOptional(output['cost'], 'number') ?? 0;
                        }
                        results.push({ type: 'output', output });
                    }
                    catch (error) {
                        results.push({ type: 'error', error: getError(error) });
                    }
                }
            }
            else {
                results = await Promise.all(range(0, splittingAmount).map(async (i) => {
                    const inputs = fromEntries(entries(inputValues).map(([port, value]) => [
                        port,
                        isArrayDataValue(value) ? arrayizeDataValue(value)[i] ?? undefined : value,
                    ]));
                    try {
                        const output = await this.#processNodeWithInputData(node, inputs, i, processId, (node, partialOutputs, index) => {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            this.#emitter.emit('partialOutput', { node, outputs: partialOutputs, index, processId });
                        });
                        if (output['cost']?.type === 'number') {
                            this.#totalCost += coerceTypeOptional(output['cost'], 'number') ?? 0;
                        }
                        return { type: 'output', output };
                    }
                    catch (error) {
                        return { type: 'error', error: getError(error) };
                    }
                }));
            }
            const errors = results.filter((r) => r.type === 'error').map((r) => r.error);
            if (errors.length === 1) {
                const e = errors[0];
                throw e;
            }
            else if (errors.length > 0) {
                throw new Error(errors.join('\n'));
            }
            // Combine the parallel results into the final output
            // Turn a Record<PortId, DataValue[]> into a Record<PortId, AnyArrayDataValue>
            const aggregateResults = results.reduce((acc, result) => {
                for (const [portId, value] of entries(result.output)) {
                    acc[portId] ??= { type: (value?.type + '[]'), value: [] };
                    acc[portId].value.push(value?.value);
                }
                return acc;
            }, {});
            this.#nodeResults.set(node.id, aggregateResults);
            this.#visitedNodes.add(node.id);
            this.#totalCost += sum(results.map((r) => coerceTypeOptional(r.output?.['cost'], 'number') ?? 0));
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('nodeFinish', { node, outputs: aggregateResults, processId });
        }
        catch (error) {
            this.#nodeErrored(node, error, processId);
        }
    }
    async #processNormalNode(node, processId) {
        const inputValues = this.#getInputValuesForNode(node);
        if (this.#excludedDueToControlFlow(node, inputValues, processId)) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('nodeStart', { node, inputs: inputValues, processId });
        try {
            const outputValues = await this.#processNodeWithInputData(node, inputValues, 0, processId, (node, partialOutputs, index) => {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.#emitter.emit('partialOutput', { node, outputs: partialOutputs, index, processId });
            });
            this.#nodeResults.set(node.id, outputValues);
            this.#visitedNodes.add(node.id);
            if (outputValues['cost']?.type === 'number') {
                this.#totalCost += coerceTypeOptional(outputValues['cost'], 'number') ?? 0;
            }
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.#emitter.emit('nodeFinish', { node, outputs: outputValues, processId });
        }
        catch (error) {
            this.#nodeErrored(node, error, processId);
        }
    }
    #nodeErrored(node, e, processId) {
        const error = getError(e);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('nodeError', { node, error, processId });
        this.#emitTraceEvent(`Node ${node.title} (${node.id}-${processId}) errored: ${error.stack}`);
        this.#erroredNodes.set(node.id, error.toString());
    }
    getRootProcessor() {
        let processor = this;
        while (processor.#parent) {
            processor = processor.#parent;
        }
        return processor;
    }
    /** Raise a user event on the processor, all subprocessors, and their children. */
    raiseEvent(event, data) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit(`userEvent:${event}`, data);
        for (const subprocessor of this.#subprocessors) {
            subprocessor.raiseEvent(event, data);
        }
    }
    #newAbortController() {
        const controller = new AbortController();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('newAbortController', controller);
        return controller;
    }
    async #processNodeWithInputData(node, inputValues, index, processId, partialOutput) {
        const instance = this.#nodeInstances[node.id];
        const nodeAbortController = this.#newAbortController();
        const abortListener = () => {
            nodeAbortController.abort();
        };
        this.#nodeAbortControllers.set(`${node.id}-${processId}`, nodeAbortController);
        this.#abortController.signal.addEventListener('abort', abortListener);
        const plugin = this.#registry.getPluginFor(node.type);
        let tokenizer = this.#context.tokenizer;
        if (!tokenizer) {
            tokenizer = new GptTokenizerTokenizer();
            tokenizer.on('error', (e) => {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.#emitter.emit('error', { error: e });
            });
        }
        const context = {
            ...this.#context,
            node,
            tokenizer,
            executor: this.executor ?? 'nodejs',
            project: this.#project,
            executionCache: this.#executionCache,
            graphInputs: this.#graphInputs,
            graphOutputs: this.#graphOutputs,
            attachedData: this.#getAttachedDataTo(node),
            waitEvent: async (event) => {
                return new Promise((resolve, reject) => {
                    this.#emitter.once(`userEvent:${event}`).then(resolve).catch(reject);
                    nodeAbortController.signal.addEventListener('abort', () => {
                        reject(new Error('Process aborted'));
                    });
                });
            },
            raiseEvent: (event, data) => {
                this.getRootProcessor().raiseEvent(event, data);
            },
            contextValues: this.#contextValues,
            externalFunctions: { ...this.#externalFunctions },
            onPartialOutputs: (partialOutputs) => {
                partialOutput?.(node, partialOutputs, index);
                const { useAsGraphPartialOutput } = node.data ?? {};
                if (useAsGraphPartialOutput && this.#executor && this.#parent) {
                    const executorNode = this.#parent.#nodesById[this.#executor.nodeId];
                    if (executorNode) {
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        this.#emitter.emit('partialOutput', {
                            index: this.#executor.index,
                            node: executorNode,
                            outputs: partialOutputs,
                            processId: this.#executor.processId,
                        });
                    }
                }
            },
            signal: nodeAbortController.signal,
            processId,
            getGlobal: (id) => this.#globals.get(id),
            setGlobal: (id, value) => {
                this.#globals.set(id, value);
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.#emitter.emit('globalSet', { id, value, processId });
            },
            waitForGlobal: async (id) => {
                if (this.#globals.has(id)) {
                    return this.#globals.get(id);
                }
                await this.getRootProcessor().#emitter.once(`globalSet:${id}`);
                return this.#globals.get(id);
            },
            createSubProcessor: (subGraphId, { signal } = {}) => {
                const processor = new GraphProcessor(this.#project, subGraphId, this.#registry);
                processor.executor = this.executor;
                processor.#isSubProcessor = true;
                processor.#executionCache = this.#executionCache;
                processor.#externalFunctions = this.#externalFunctions;
                processor.#contextValues = this.#contextValues;
                processor.#parent = this;
                processor.#globals = this.#globals;
                processor.#executor = {
                    nodeId: node.id,
                    index,
                    processId,
                };
                processor.on('nodeError', (e) => this.#emitter.emit('nodeError', e));
                processor.on('nodeFinish', (e) => this.#emitter.emit('nodeFinish', e));
                processor.on('partialOutput', (e) => this.#emitter.emit('partialOutput', e));
                processor.on('nodeExcluded', (e) => this.#emitter.emit('nodeExcluded', e));
                processor.on('nodeStart', (e) => this.#emitter.emit('nodeStart', e));
                processor.on('graphAbort', (e) => this.#emitter.emit('graphAbort', e));
                processor.on('userInput', (e) => this.#emitter.emit('userInput', e)); // TODO!
                processor.on('graphStart', (e) => this.#emitter.emit('graphStart', e));
                processor.on('graphFinish', (e) => this.#emitter.emit('graphFinish', e));
                processor.on('globalSet', (e) => this.#emitter.emit('globalSet', e));
                processor.on('newAbortController', (e) => this.#emitter.emit('newAbortController', e));
                processor.on('pause', () => {
                    if (!this.#isPaused) {
                        this.pause();
                    }
                });
                processor.on('resume', () => {
                    if (this.#isPaused) {
                        this.resume();
                    }
                });
                processor.onAny((event, data) => {
                    if (event.startsWith('globalSet:')) {
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        this.#emitter.emit(event, data);
                    }
                });
                this.#subprocessors.add(processor);
                if (signal) {
                    signal.addEventListener('abort', () => {
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        processor.abort();
                    });
                }
                // If parent is aborted, abort subgraph with error (it's fine, success state is on the parent)
                this.#abortController.signal.addEventListener('abort', () => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    processor.abort();
                });
                this.on('pause', () => processor.pause());
                this.on('resume', () => processor.resume());
                return processor;
            },
            trace: (message) => {
                this.#emitTraceEvent(message);
            },
            abortGraph: (error) => {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.abort(error === undefined, error);
            },
            getPluginConfig: (name) => getPluginConfig(plugin, this.#context.settings, name),
            requestUserInput: async (inputStrings, renderingType) => {
                const results = await new Promise((resolve, reject) => {
                    this.#pendingUserInputs[node.id] = {
                        resolve,
                        reject,
                    };
                    this.#abortController.signal.addEventListener('abort', () => {
                        delete this.#pendingUserInputs[node.id];
                        reject(new Error('Processing aborted'));
                    });
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    this.#emitter.emit('userInput', {
                        node,
                        inputStrings,
                        inputs: inputValues,
                        renderingType,
                        callback: (results) => {
                            resolve(results);
                            delete this.#pendingUserInputs[node.id];
                        },
                        processId,
                    });
                });
                return results;
            },
        };
        await this.#waitUntilUnpaused();
        const results = await instance.process(inputValues, context);
        this.#nodeAbortControllers.delete(`${node.id}-${processId}`);
        this.#abortController.signal.removeEventListener('abort', abortListener);
        if (nodeAbortController.signal.aborted) {
            throw new Error('Aborted');
        }
        return results;
    }
    #excludedDueToControlFlow(node, inputValues, processId, typeOfExclusion = undefined) {
        if (node.disabled) {
            this.#emitTraceEvent(`Excluding node ${node.title} because it's disabled`);
            this.#visitedNodes.add(node.id);
            this.#markAsExcluded(node, processId, inputValues, 'disabled');
            return true;
        }
        if (node.isConditional && typeOfExclusion === undefined) {
            const ifValue = coerceTypeOptional(inputValues[IF_PORT.id], 'boolean');
            if (ifValue === false) {
                this.#emitTraceEvent(`Excluding node ${node.title} because if port is false`);
                this.#visitedNodes.add(node.id);
                this.#markAsExcluded(node, processId, inputValues, 'if port is false');
                return true;
            }
        }
        const inputsWithValues = entries(inputValues);
        const controlFlowExcludedValues = inputsWithValues.filter(([, value]) => value &&
            getScalarTypeOf(value.type) === 'control-flow-excluded' &&
            (!typeOfExclusion || value.value === typeOfExclusion));
        const inputIsExcludedValue = inputsWithValues.length > 0 && controlFlowExcludedValues.length > 0;
        const isWaitingForLoop = controlFlowExcludedValues.some((value) => value?.[1]?.value === 'loop-not-broken');
        const nodesAllowedToConsumeExcludedValue = [
            'if',
            'ifElse',
            'coalesce',
            'graphOutput',
            'raceInputs',
            'loopController',
        ];
        const allowedToConsumedExcludedValue = nodesAllowedToConsumeExcludedValue.includes(node.type) && !isWaitingForLoop;
        if (inputIsExcludedValue && !allowedToConsumedExcludedValue) {
            if (!isWaitingForLoop) {
                if (inputIsExcludedValue) {
                    this.#emitTraceEvent(`Excluding node ${node.title} because of control flow. Input is has excluded value: ${controlFlowExcludedValues[0]?.[0]}`);
                }
                this.#visitedNodes.add(node.id);
                this.#markAsExcluded(node, processId, inputValues, 'input is excluded value');
            }
            return true;
        }
        return false;
    }
    #markAsExcluded(node, processId, inputValues, reason) {
        const outputs = {};
        for (const output of this.#definitions[node.id].outputs) {
            outputs[output.id] = { type: 'control-flow-excluded', value: undefined };
        }
        // Prevent infinite loop, a control-flow-excluded to loop controller shouldn't set the break port, let the loop controller handle it
        if (node.type === 'loopController') {
            outputs['break'] = { type: 'control-flow-excluded', value: 'loop-not-broken' };
        }
        this.#nodeResults.set(node.id, outputs);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.#emitter.emit('nodeExcluded', {
            node,
            processId,
            inputs: inputValues,
            outputs,
            reason,
        });
    }
    #getInputValuesForNode(node) {
        const connections = this.#connections[node.id];
        return this.#definitions[node.id].inputs.reduce((values, input) => {
            if (!connections) {
                return values;
            }
            const connection = connections.find((conn) => conn.inputId === input.id && conn.inputNodeId === node.id);
            if (connection) {
                const outputNode = this.#nodeInstances[connection.outputNodeId].chartNode;
                const outputNodeOutputs = this.#nodeResults.get(outputNode.id);
                const outputResult = outputNodeOutputs?.[connection.outputId];
                values[input.id] = outputResult;
            }
            return values;
        }, {});
    }
    /** Gets the nodes that are inputting to the given node. */
    #inputNodesTo(node) {
        const connections = this.#connections[node.id];
        if (!connections) {
            return [];
        }
        const connectionsToNode = connections.filter((conn) => conn.inputNodeId === node.id).filter(isNotNull);
        // Filter out invalid connections
        const inputDefinitions = this.#definitions[node.id]?.inputs ?? [];
        return connectionsToNode
            .filter((connection) => {
            const connectionDefinition = inputDefinitions.find((def) => def.id === connection.inputId);
            return connectionDefinition != null;
        })
            .map((conn) => this.#nodesById[conn.outputNodeId])
            .filter(isNotNull);
    }
    /** Gets the nodes that the given node it outputting to. */
    #outputNodesFrom(node) {
        const connections = this.#connections[node.id];
        if (!connections) {
            return { nodes: [], connections: [], connectionsToNodes: [] };
        }
        const connectionsToNode = connections.filter((conn) => conn.outputNodeId === node.id);
        // Filter out invalid connections
        const outputDefinitions = this.#definitions[node.id]?.outputs ?? [];
        const outputConnections = connectionsToNode.filter((connection) => {
            const connectionDefinition = outputDefinitions.find((def) => def.id === connection.outputId);
            return connectionDefinition != null;
        });
        const outputNodes = uniqBy(outputConnections.map((conn) => this.#nodesById[conn.inputNodeId]).filter(isNotNull), (x) => x.id);
        const connectionsToNodes = [];
        outputNodes.forEach((node) => {
            const connections = outputConnections.filter((conn) => conn.inputNodeId === node.id);
            connectionsToNodes.push({ connections, node });
        });
        return { nodes: outputNodes, connections: outputConnections, connectionsToNodes };
    }
    #tarjanSCC() {
        let index = 0;
        const stack = [];
        const indices = new Map();
        const lowLinks = new Map();
        const onStack = new Map();
        const sccs = [];
        const strongConnect = (node) => {
            indices.set(node.id, index);
            lowLinks.set(node.id, index);
            index++;
            stack.push(node);
            onStack.set(node.id, true);
            const outgoingConnections = this.#connections[node.id]?.filter((conn) => conn.outputNodeId === node.id);
            for (const connection of outgoingConnections ?? []) {
                const successor = this.#nodesById[connection.inputNodeId];
                if (!indices.has(successor.id)) {
                    strongConnect(successor);
                    lowLinks.set(node.id, Math.min(lowLinks.get(node.id), lowLinks.get(successor.id)));
                }
                else if (onStack.get(successor.id)) {
                    lowLinks.set(node.id, Math.min(lowLinks.get(node.id), indices.get(successor.id)));
                }
            }
            if (lowLinks.get(node.id) === indices.get(node.id)) {
                const scc = [];
                let connectedNode;
                do {
                    connectedNode = stack.pop();
                    onStack.set(connectedNode.id, false);
                    scc.push(connectedNode);
                } while (connectedNode.id !== node.id);
                sccs.push(scc);
            }
        };
        for (const node of this.#graph.nodes) {
            if (!indices.has(node.id)) {
                strongConnect(node);
            }
        }
        return sccs;
    }
    #nodeIsInCycle(nodeId) {
        return this.#nodesNotInCycle.find((node) => node.id === nodeId) == null;
    }
    #nodesAreInSameCycle(a, b) {
        return this.#scc.find((cycle) => cycle.find((node) => node.id === a) && cycle.find((node) => node.id === b));
    }
}
